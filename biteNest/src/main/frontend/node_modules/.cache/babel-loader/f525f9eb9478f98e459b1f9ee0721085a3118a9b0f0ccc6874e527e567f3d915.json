{"ast":null,"code":"const getResponse = async ({\n  request,\n  requestId,\n  handlers,\n  resolutionContext\n}) => {\n  let matchingHandler = null;\n  let result = null;\n  for (const handler of handlers) {\n    result = await handler.run({\n      request,\n      requestId,\n      resolutionContext\n    });\n    if (result !== null) {\n      matchingHandler = handler;\n    }\n    if (result?.response) {\n      break;\n    }\n  }\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response\n    };\n  }\n  return null;\n};\nexport { getResponse };","map":{"version":3,"names":["getResponse","request","requestId","handlers","resolutionContext","matchingHandler","result","handler","run","response","parsedResult"],"sources":["/Users/leeyangie/Documents/GitHub/BiteNest/biteNest/src/main/frontend/.yarn/unplugged/msw-virtual-c17a34f746/node_modules/msw/src/core/utils/getResponse.ts"],"sourcesContent":["import {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface ResponseLookupResult {\n  handler: RequestHandler\n  parsedResult?: any\n  response?: Response\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <Handler extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request\n  requestId: string\n  handlers: Handler\n  resolutionContext?: ResponseResolutionContext\n}): Promise<ResponseLookupResult | null> => {\n  let matchingHandler: RequestHandler | null = null\n  let result: RequestHandlerExecutionResult<any> | null = null\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext })\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    }\n  }\n\n  return null\n}\n"],"mappings":"AAkBO,MAAMA,WAAA,GAAc,MAAAA,CAA8C;EACvEC,OAAA;EACAC,SAAA;EACAC,QAAA;EACAC;AACF,MAK4C;EAC1C,IAAIC,eAAA,GAAyC;EAC7C,IAAIC,MAAA,GAAoD;EAExD,WAAWC,OAAA,IAAWJ,QAAA,EAAU;IAC9BG,MAAA,GAAS,MAAMC,OAAA,CAAQC,GAAA,CAAI;MAAEP,OAAA;MAASC,SAAA;MAAWE;IAAkB,CAAC;IAIpE,IAAIE,MAAA,KAAW,MAAM;MACnBD,eAAA,GAAkBE,OAAA;IACpB;IAOA,IAAID,MAAA,EAAQG,QAAA,EAAU;MACpB;IACF;EACF;EAEA,IAAIJ,eAAA,EAAiB;IACnB,OAAO;MACLE,OAAA,EAASF,eAAA;MACTK,YAAA,EAAcJ,MAAA,EAAQI,YAAA;MACtBD,QAAA,EAAUH,MAAA,EAAQG;IACpB;EACF;EAEA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}