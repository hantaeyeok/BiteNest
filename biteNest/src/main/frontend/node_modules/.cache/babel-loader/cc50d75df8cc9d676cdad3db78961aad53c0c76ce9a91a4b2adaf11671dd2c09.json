{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interceptor = exports.InterceptorReadyState = exports.deleteGlobalSymbol = exports.getGlobalSymbol = void 0;\nvar debug_1 = require(\"debug\");\nvar AsyncEventEmitter_1 = require(\"./utils/AsyncEventEmitter\");\nvar nextTick_1 = require(\"./utils/nextTick\");\nfunction getGlobalSymbol(symbol) {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  );\n}\nexports.getGlobalSymbol = getGlobalSymbol;\nfunction setGlobalSymbol(symbol, value) {\n  // @ts-ignore\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  // @ts-ignore\n  delete globalThis[symbol];\n}\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nvar InterceptorReadyState;\n(function (InterceptorReadyState) {\n  InterceptorReadyState[\"IDLE\"] = \"IDLE\";\n  InterceptorReadyState[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState[\"DISPOSED\"] = \"DISPOSED\";\n})(InterceptorReadyState = exports.InterceptorReadyState || (exports.InterceptorReadyState = {}));\nvar Interceptor = /** @class */function () {\n  function Interceptor(symbol) {\n    this.symbol = symbol;\n    this.readyState = InterceptorReadyState.IDLE;\n    this.emitter = new AsyncEventEmitter_1.AsyncEventEmitter();\n    this.subscriptions = [];\n    this.log = debug_1.debug(symbol.description);\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0);\n    this.log('constructing the interceptor...');\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  Interceptor.prototype.checkEnvironment = function () {\n    return true;\n  };\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  Interceptor.prototype.apply = function () {\n    var _this = this;\n    var log = this.log.extend('apply');\n    log('applying the interceptor...');\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!');\n      return;\n    }\n    var shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!');\n      return;\n    }\n    this.readyState = InterceptorReadyState.APPLYING;\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate();\n    log('activated the emiter!', this.emitter.readyState);\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    var runningInstance = this.getInstance();\n    if (runningInstance) {\n      log('found a running instance, reusing...');\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = function (event, listener) {\n        log('proxying the \"%s\" listener', event);\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener);\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        _this.subscriptions.push(function () {\n          runningInstance.emitter.removeListener(event, listener);\n          log('removed proxied \"%s\" listener!', event);\n        });\n      };\n      nextTick_1.nextTick(function () {\n        _this.readyState = InterceptorReadyState.APPLIED;\n      });\n      return;\n    }\n    log('no running instance found, setting up a new instance...');\n    // Setup the interceptor.\n    this.setup();\n    // Store the newly applied interceptor instance globally.\n    this.setInstance();\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.APPLIED;\n    });\n  };\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  Interceptor.prototype.setup = function () {};\n  /**\n   * Listen to the interceptor's public events.\n   */\n  Interceptor.prototype.on = function (event, listener) {\n    var log = this.log.extend('on');\n    if (this.readyState === InterceptorReadyState.DISPOSING || this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot listen to events, already disposed!');\n      return;\n    }\n    log('adding \"%s\" event listener:', event, listener.name);\n    this.emitter.on(event, listener);\n  };\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  Interceptor.prototype.dispose = function () {\n    var e_1, _a;\n    var _this = this;\n    var log = this.log.extend('dispose');\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!');\n      return;\n    }\n    log('disposing the interceptor...');\n    this.readyState = InterceptorReadyState.DISPOSING;\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...');\n      return;\n    }\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance();\n    log('global symbol deleted:', getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length);\n      try {\n        for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dispose = _c.value;\n          dispose();\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      this.subscriptions = [];\n      log('disposed of all subscriptions!', this.subscriptions.length);\n    }\n    this.emitter.deactivate();\n    log('destroyed the listener!');\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.DISPOSED;\n    });\n  };\n  Interceptor.prototype.getInstance = function () {\n    var _a;\n    var instance = getGlobalSymbol(this.symbol);\n    this.log('retrieved global instance:', (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name);\n    return instance;\n  };\n  Interceptor.prototype.setInstance = function () {\n    setGlobalSymbol(this.symbol, this);\n    this.log('set global instance!', this.symbol.description);\n  };\n  Interceptor.prototype.clearInstance = function () {\n    deleteGlobalSymbol(this.symbol);\n    this.log('cleared global instance!', this.symbol.description);\n  };\n  return Interceptor;\n}();\nexports.Interceptor = Interceptor;","map":{"version":3,"names":["debug_1","require","AsyncEventEmitter_1","nextTick_1","getGlobalSymbol","symbol","globalThis","undefined","exports","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","Interceptor","readyState","IDLE","emitter","AsyncEventEmitter","subscriptions","log","debug","description","setMaxListeners","prototype","checkEnvironment","apply","_this","extend","APPLIED","shouldApply","APPLYING","activate","runningInstance","getInstance","on","event","listener","addListener","push","removeListener","nextTick","setup","setInstance","DISPOSING","DISPOSED","name","dispose","clearInstance","length","_b","__values","_c","next","done","deactivate","instance","_a","constructor"],"sources":["/Users/leeyangie/.yarn/berry/cache/@mswjs-interceptors-npm-0.17.10-c1199a9424-10c0.zip/node_modules/@mswjs/interceptors/src/Interceptor.ts"],"sourcesContent":["import { Debugger, debug } from 'debug'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter'\nimport { nextTick } from './utils/nextTick'\n\nexport type InterceptorEventMap = Record<string, (...args: any[]) => void>\nexport type InterceptorSubscription = () => void\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  IDLE = 'IDLE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<EventMap extends Record<string, any>> =\n  EventMap extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<EventMap extends InterceptorEventMap> {\n  protected emitter: AsyncEventEmitter<EventMap>\n  protected subscriptions: InterceptorSubscription[]\n  protected log: Debugger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: Symbol) {\n    this.readyState = InterceptorReadyState.IDLE\n\n    this.emitter = new AsyncEventEmitter()\n    this.subscriptions = []\n    this.log = debug(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.log('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const log = this.log.extend('apply')\n    log('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate()\n    log('activated the emiter!', this.emitter.readyState)\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      log('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        log('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          log('removed proxied \"%s\" listener!', event)\n        })\n      }\n\n      nextTick(() => {\n        this.readyState = InterceptorReadyState.APPLIED\n      })\n\n      return\n    }\n\n    log('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.APPLIED\n    })\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<Event extends ExtractEventNames<EventMap>>(\n    event: Event,\n    listener: EventMap[Event]\n  ): void {\n    const log = this.log.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      log('cannot listen to events, already disposed!')\n      return\n    }\n\n    log('adding \"%s\" event listener:', event, listener.name)\n\n    this.emitter.on(event, listener)\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const log = this.log.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!')\n      return\n    }\n\n    log('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    log('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      log('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.deactivate()\n    log('destroyed the listener!')\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.DISPOSED\n    })\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.log('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.log('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.log('cleared global instance!', this.symbol.description)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}