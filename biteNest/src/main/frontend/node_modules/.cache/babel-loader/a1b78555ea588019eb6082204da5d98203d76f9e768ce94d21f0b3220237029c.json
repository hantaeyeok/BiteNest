{"ast":null,"code":"function _array_like_to_array(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _array_with_holes(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _class_call_check(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return !!right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\nfunction _iterable_to_array_limit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _non_iterable_rest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n  var f,\n    y,\n    t,\n    g,\n    _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    };\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = function (cb, mod) {\n  return function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n      exports: {}\n    }).exports, mod), mod.exports;\n  };\n};\nvar __export = function (target, all) {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = function (to, from, except, desc) {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    var _iteratorNormalCompletion = true,\n      _didIteratorError = false,\n      _iteratorError = undefined;\n    try {\n      var _loop = function () {\n        var key = _step.value;\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n          get: function () {\n            return from[key];\n          },\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n      };\n      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) _loop();\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  return to;\n};\nvar __toESM = function (mod, isNodeMode, target) {\n  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n    value: mod,\n    enumerable: true\n  }) : target, mod);\n};\nvar __toCommonJS = function (mod) {\n  return __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n};\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\": function (exports, module2) {\n    \"use strict\";\n\n    var isNonEmptyString = function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    };\n    var parseString = function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n      }\n      var cookie = {\n        name: name,\n        value: value\n      };\n      parts.forEach(function (part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    };\n    var parseNameValuePair = function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n      return {\n        name: name,\n        value: value\n      };\n    };\n    var parse = function parse(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n          }\n          input = sch;\n        }\n      }\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function (str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function (cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    };\n    var splitCookiesString2 = function splitCookiesString2(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n        return pos < cookiesString.length;\n      }\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n      return cookiesStrings;\n    };\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n    module2.exports = parse;\n    module2.exports.parse = parse;\n    module2.exports.parseString = parseString;\n    module2.exports.splitCookiesString = splitCookiesString2;\n  }\n});\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  Headers: function () {\n    return Headers;\n  },\n  flattenHeadersList: function () {\n    return flattenHeadersList;\n  },\n  flattenHeadersObject: function () {\n    return flattenHeadersObject;\n  },\n  getRawHeaders: function () {\n    return getRawHeaders;\n  },\n  headersToList: function () {\n    return headersToList;\n  },\n  headersToObject: function () {\n    return headersToObject;\n  },\n  headersToString: function () {\n    return headersToString;\n  },\n  listToHeaders: function () {\n    return listToHeaders;\n  },\n  objectToHeaders: function () {\n    return objectToHeaders;\n  },\n  reduceHeadersObject: function () {\n    return reduceHeadersObject;\n  },\n  stringToHeaders: function () {\n    return stringToHeaders;\n  }\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/Headers.ts\nvar import_set_cookie_parser = __toESM(require_set_cookie());\n// src/utils/normalizeHeaderName.ts\nvar HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i;\nfunction normalizeHeaderName(name) {\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === \"\") {\n    throw new TypeError(\"Invalid character in header field name\");\n  }\n  return name.trim().toLowerCase();\n}\n// src/utils/normalizeHeaderValue.ts\nvar charCodesToRemove = [String.fromCharCode(10), String.fromCharCode(13), String.fromCharCode(9), String.fromCharCode(32)];\nvar HEADER_VALUE_REMOVE_REGEXP = new RegExp(\"(^[\".concat(charCodesToRemove.join(\"\"), \"]|$[\").concat(charCodesToRemove.join(\"\"), \"])\"), \"g\");\nfunction normalizeHeaderValue(value) {\n  var nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, \"\");\n  return nextValue;\n}\n// src/utils/isValidHeaderName.ts\nfunction isValidHeaderName(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  if (value.length === 0) {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var character = value.charCodeAt(i);\n    if (character > 127 || !isToken(character)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isToken(value) {\n  return ![127, 32, \"(\", \")\", \"<\", \">\", \"@\", \",\", \";\", \":\", \"\\\\\", '\"', \"/\", \"[\", \"]\", \"?\", \"=\", \"{\", \"}\"].includes(value);\n}\n// src/utils/isValidHeaderValue.ts\nfunction isValidHeaderValue(value) {\n  if (typeof value !== \"string\") {\n    return false;\n  }\n  if (value.trim() !== value) {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var character = value.charCodeAt(i);\n    if (\n    // NUL.\n    character === 0 ||\n    // HTTP newline bytes.\n    character === 10 || character === 13) {\n      return false;\n    }\n  }\n  return true;\n}\n// src/Headers.ts\nvar NORMALIZED_HEADERS = Symbol(\"normalizedHeaders\");\nvar RAW_HEADER_NAMES = Symbol(\"rawHeaderNames\");\nvar HEADER_VALUE_DELIMITER = \", \";\nvar _a, _b;\nvar Headers = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _Headers(init) {\n    var _this = this;\n    _class_call_check(this, _Headers);\n    var _init;\n    // Normalized header {\"name\":\"a, b\"} storage.\n    this[_a] = {};\n    // Keeps the mapping between the raw header name\n    // and the normalized header name to ease the lookup.\n    this[_b] = /* @__PURE__ */new Map();\n    if ([\"Headers\", \"HeadersPolyfill\"].includes((_init = init) === null || _init === void 0 ? void 0 : _init.constructor.name) || _instanceof(init, _Headers)) {\n      var initialHeaders = init;\n      initialHeaders.forEach(function (value, name) {\n        _this.append(name, value);\n      }, this);\n    } else if (Array.isArray(init)) {\n      init.forEach(function (param) {\n        var _param = _sliced_to_array(param, 2),\n          name = _param[0],\n          value = _param[1];\n        _this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n      });\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach(function (name) {\n        var value = init[name];\n        _this.append(name, Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value);\n      });\n    }\n  }\n  _create_class(_Headers, [{\n    key: (_a = NORMALIZED_HEADERS, _b = RAW_HEADER_NAMES, Symbol.iterator),\n    value: function value() {\n      return this.entries();\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step_value, name, err;\n      return _ts_generator(this, function (_state) {\n        switch (_state.label) {\n          case 0:\n            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            _state.label = 1;\n          case 1:\n            _state.trys.push([1, 6, 7, 8]);\n            _iterator = this.entries()[Symbol.iterator]();\n            _state.label = 2;\n          case 2:\n            if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [3, 5];\n            _step_value = _sliced_to_array(_step.value, 1), name = _step_value[0];\n            return [4, name];\n          case 3:\n            _state.sent();\n            _state.label = 4;\n          case 4:\n            _iteratorNormalCompletion = true;\n            return [3, 2];\n          case 5:\n            return [3, 8];\n          case 6:\n            err = _state.sent();\n            _didIteratorError = true;\n            _iteratorError = err;\n            return [3, 8];\n          case 7:\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n            return [7];\n          case 8:\n            return [2];\n        }\n      });\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step_value, value, err;\n      return _ts_generator(this, function (_state) {\n        switch (_state.label) {\n          case 0:\n            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            _state.label = 1;\n          case 1:\n            _state.trys.push([1, 6, 7, 8]);\n            _iterator = this.entries()[Symbol.iterator]();\n            _state.label = 2;\n          case 2:\n            if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [3, 5];\n            _step_value = _sliced_to_array(_step.value, 2), value = _step_value[1];\n            return [4, value];\n          case 3:\n            _state.sent();\n            _state.label = 4;\n          case 4:\n            _iteratorNormalCompletion = true;\n            return [3, 2];\n          case 5:\n            return [3, 8];\n          case 6:\n            err = _state.sent();\n            _didIteratorError = true;\n            _iteratorError = err;\n            return [3, 8];\n          case 7:\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n            return [7];\n          case 8:\n            return [2];\n        }\n      });\n    }\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var sortedKeys, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, name, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, value, err, err;\n      return _ts_generator(this, function (_state) {\n        switch (_state.label) {\n          case 0:\n            sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort(function (a, b) {\n              return a.localeCompare(b);\n            });\n            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            _state.label = 1;\n          case 1:\n            _state.trys.push([1, 15, 16, 17]);\n            _iterator = sortedKeys[Symbol.iterator]();\n            _state.label = 2;\n          case 2:\n            if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [3, 14];\n            name = _step.value;\n            if (!(name === \"set-cookie\")) return [3, 11];\n            _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n            _state.label = 3;\n          case 3:\n            _state.trys.push([3, 8, 9, 10]);\n            _iterator1 = this.getSetCookie()[Symbol.iterator]();\n            _state.label = 4;\n          case 4:\n            if (!!(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done)) return [3, 7];\n            value = _step1.value;\n            return [4, [name, value]];\n          case 5:\n            _state.sent();\n            _state.label = 6;\n          case 6:\n            _iteratorNormalCompletion1 = true;\n            return [3, 4];\n          case 7:\n            return [3, 10];\n          case 8:\n            err = _state.sent();\n            _didIteratorError1 = true;\n            _iteratorError1 = err;\n            return [3, 10];\n          case 9:\n            try {\n              if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                _iterator1.return();\n              }\n            } finally {\n              if (_didIteratorError1) {\n                throw _iteratorError1;\n              }\n            }\n            return [7];\n          case 10:\n            return [3, 13];\n          case 11:\n            return [4, [name, this.get(name)]];\n          case 12:\n            _state.sent();\n            _state.label = 13;\n          case 13:\n            _iteratorNormalCompletion = true;\n            return [3, 2];\n          case 14:\n            return [3, 17];\n          case 15:\n            err = _state.sent();\n            _didIteratorError = true;\n            _iteratorError = err;\n            return [3, 17];\n          case 16:\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n            return [7];\n          case 17:\n            return [2];\n        }\n      });\n    }\n  }, {\n    /**\n    * Returns a boolean stating whether a `Headers` object contains a certain header.\n    */\n    key: \"has\",\n    value: function has(name) {\n      if (!isValidHeaderName(name)) {\n        throw new TypeError('Invalid header name \"'.concat(name, '\"'));\n      }\n      return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name));\n    }\n  }, {\n    /**\n    * Returns a `ByteString` sequence of all the values of a header with a given name.\n    */\n    key: \"get\",\n    value: function get(name) {\n      if (!isValidHeaderName(name)) {\n        throw TypeError('Invalid header name \"'.concat(name, '\"'));\n      }\n      var _this_NORMALIZED_HEADERS_normalizeHeaderName;\n      return (_this_NORMALIZED_HEADERS_normalizeHeaderName = this[NORMALIZED_HEADERS][normalizeHeaderName(name)]) !== null && _this_NORMALIZED_HEADERS_normalizeHeaderName !== void 0 ? _this_NORMALIZED_HEADERS_normalizeHeaderName : null;\n    }\n  }, {\n    /**\n    * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n    */\n    key: \"set\",\n    value: function set(name, value) {\n      if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n        return;\n      }\n      var normalizedName = normalizeHeaderName(name);\n      var normalizedValue = normalizeHeaderValue(value);\n      this[NORMALIZED_HEADERS][normalizedName] = normalizeHeaderValue(normalizedValue);\n      this[RAW_HEADER_NAMES].set(normalizedName, name);\n    }\n  }, {\n    /**\n    * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n    */\n    key: \"append\",\n    value: function append(name, value) {\n      if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n        return;\n      }\n      var normalizedName = normalizeHeaderName(name);\n      var normalizedValue = normalizeHeaderValue(value);\n      var resolvedValue = this.has(normalizedName) ? \"\".concat(this.get(normalizedName), \", \").concat(normalizedValue) : normalizedValue;\n      this.set(name, resolvedValue);\n    }\n  }, {\n    /**\n    * Deletes a header from the `Headers` object.\n    */\n    key: \"delete\",\n    value: function _delete(name) {\n      if (!isValidHeaderName(name)) {\n        return;\n      }\n      if (!this.has(name)) {\n        return;\n      }\n      var normalizedName = normalizeHeaderName(name);\n      delete this[NORMALIZED_HEADERS][normalizedName];\n      this[RAW_HEADER_NAMES].delete(normalizedName);\n    }\n  }, {\n    /**\n    * Traverses the `Headers` object,\n    * calling the given callback for each header.\n    */\n    key: \"forEach\",\n    value: function forEach(callback, thisArg) {\n      var _iteratorNormalCompletion = true,\n        _didIteratorError = false,\n        _iteratorError = undefined;\n      try {\n        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step_value = _sliced_to_array(_step.value, 2),\n            name = _step_value[0],\n            value = _step_value[1];\n          callback.call(thisArg, value, name, this);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    /**\n    * Returns an array containing the values\n    * of all Set-Cookie headers associated\n    * with a response\n    */\n    key: \"getSetCookie\",\n    value: function getSetCookie() {\n      var setCookieHeader = this.get(\"set-cookie\");\n      if (setCookieHeader === null) {\n        return [];\n      }\n      if (setCookieHeader === \"\") {\n        return [\"\"];\n      }\n      return (0, import_set_cookie_parser.splitCookiesString)(setCookieHeader);\n    }\n  }]);\n  return _Headers;\n}();\n// src/getRawHeaders.ts\nfunction getRawHeaders(headers) {\n  var rawHeaders = {};\n  var _iteratorNormalCompletion = true,\n    _didIteratorError = false,\n    _iteratorError = undefined;\n  try {\n    for (var _iterator = headers.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step_value = _sliced_to_array(_step.value, 2),\n        name = _step_value[0],\n        value = _step_value[1];\n      rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n  return rawHeaders;\n}\n// src/transformers/headersToList.ts\nfunction headersToList(headers) {\n  var headersList = [];\n  headers.forEach(function (value, name) {\n    var resolvedValue = value.includes(\",\") ? value.split(\",\").map(function (value2) {\n      return value2.trim();\n    }) : value;\n    headersList.push([name, resolvedValue]);\n  });\n  return headersList;\n}\n// src/transformers/headersToString.ts\nfunction headersToString(headers) {\n  var list = headersToList(headers);\n  var lines = list.map(function (param) {\n    var _param = _sliced_to_array(param, 2),\n      name = _param[0],\n      value = _param[1];\n    var values = [].concat(value);\n    return \"\".concat(name, \": \").concat(values.join(\", \"));\n  });\n  return lines.join(\"\\r\\n\");\n}\n// src/transformers/headersToObject.ts\nvar singleValueHeaders = [\"user-agent\"];\nfunction headersToObject(headers) {\n  var headersObject = {};\n  headers.forEach(function (value, name) {\n    var isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(\",\");\n    headersObject[name] = isMultiValue ? value.split(\",\").map(function (s) {\n      return s.trim();\n    }) : value;\n  });\n  return headersObject;\n}\n// src/transformers/stringToHeaders.ts\nfunction stringToHeaders(str) {\n  var lines = str.trim().split(/[\\r\\n]+/);\n  return lines.reduce(function (headers, line) {\n    if (line.trim() === \"\") {\n      return headers;\n    }\n    var parts = line.split(\": \");\n    var name = parts.shift();\n    var value = parts.join(\": \");\n    headers.append(name, value);\n    return headers;\n  }, new Headers());\n}\n// src/transformers/listToHeaders.ts\nfunction listToHeaders(list) {\n  var headers = new Headers();\n  list.forEach(function (param) {\n    var _param = _sliced_to_array(param, 2),\n      name = _param[0],\n      value = _param[1];\n    var values = [].concat(value);\n    values.forEach(function (value2) {\n      headers.append(name, value2);\n    });\n  });\n  return headers;\n}\n// src/transformers/reduceHeadersObject.ts\nfunction reduceHeadersObject(headers, reducer, initialState) {\n  return Object.keys(headers).reduce(function (nextHeaders, name) {\n    return reducer(nextHeaders, name, headers[name]);\n  }, initialState);\n}\n// src/transformers/objectToHeaders.ts\nfunction objectToHeaders(headersObject) {\n  return reduceHeadersObject(headersObject, function (headers, name, value) {\n    var values = [].concat(value).filter(Boolean);\n    values.forEach(function (value2) {\n      headers.append(name, value2);\n    });\n    return headers;\n  }, new Headers());\n}\n// src/transformers/flattenHeadersList.ts\nfunction flattenHeadersList(list) {\n  return list.map(function (param) {\n    var _param = _sliced_to_array(param, 2),\n      name = _param[0],\n      values = _param[1];\n    return [name, [].concat(values).join(\", \")];\n  });\n}\n// src/transformers/flattenHeadersObject.ts\nfunction flattenHeadersObject(headersObject) {\n  return reduceHeadersObject(headersObject, function (headers, name, value) {\n    headers[name] = [].concat(value).join(\", \");\n    return headers;\n  }, {});\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  Headers: Headers,\n  flattenHeadersList: flattenHeadersList,\n  flattenHeadersObject: flattenHeadersObject,\n  getRawHeaders: getRawHeaders,\n  headersToList: headersToList,\n  headersToObject: headersToObject,\n  headersToString: headersToString,\n  listToHeaders: listToHeaders,\n  objectToHeaders: objectToHeaders,\n  reduceHeadersObject: reduceHeadersObject,\n  stringToHeaders: stringToHeaders\n});","map":{"version":3,"names":["_iterable_to_array_limit","arr","i","_i","Symbol","iterator","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","_non_iterable_rest","TypeError","_sliced_to_array","_array_with_holes","_unsupported_iterable_to_array","o","minLen","_array_like_to_array","n","Object","prototype","toString","slice","constructor","name","Array","from","test","_ts_generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","verb","v","step","op","pop","e","__create","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","hasOwnProperty","__commonJS","cb","mod","__require","exports","__export","target","all","get","enumerable","__copyProps","to","except","desc","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_loop","key","_step","_iterator","return","__toESM","isNodeMode","__esModule","require_set_cookie","node_modules/set-cookie-parser/lib/set-cookie.js","module2","isNonEmptyString","str","trim","parseString","setCookieValue","options","parts","split","filter","nameValuePairStr","shift","parsed","parseNameValuePair","assign","defaultParseOptions","decodeValues","decodeURIComponent","console","error","cookie","forEach","part","sides","trimLeft","toLowerCase","value2","join","expires","Date","maxAge","parseInt","secure","httpOnly","sameSite","nameValueArr","parse","input","map","headers","getSetCookie","sch","silent","warn","isArray","cookies","reduce","cookies2","splitCookiesString2","cookiesString","cookiesStrings","pos","start","ch","lastComma","nextStart","cookiesSeparatorFound","skipWhitespace","charAt","notSpecialChar","substring","splitCookiesString","src_exports","Headers","flattenHeadersList","flattenHeadersObject","getRawHeaders","headersToList","headersToObject","headersToString","listToHeaders","objectToHeaders","reduceHeadersObject","stringToHeaders","module","__toCommonJS","import_set_cookie_parser","HEADERS_INVALID_CHARACTERS","normalizeHeaderName","String","fromCharCode","HEADER_VALUE_REMOVE_REGEXP","RegExp","concat","charCodesToRemove","normalizeHeaderValue","isValidHeaderName","character","charCodeAt","isToken","includes","isValidHeaderValue","NORMALIZED_HEADERS","RAW_HEADER_NAMES","HEADER_VALUE_DELIMITER","_a","_b","_Headers","init","_this","_class_call_check","_init","Map","_instanceof","append","param","_param","_create_class"],"sources":["/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/node_modules/set-cookie-parser/lib/set-cookie.js","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/index.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/Headers.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/utils/normalizeHeaderName.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/utils/normalizeHeaderValue.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/utils/isValidHeaderName.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/utils/isValidHeaderValue.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/getRawHeaders.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/headersToList.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/headersToString.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/headersToObject.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/stringToHeaders.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/listToHeaders.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/reduceHeadersObject.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/objectToHeaders.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/flattenHeadersList.ts","/Users/leeyangie/.yarn/berry/cache/headers-polyfill-npm-3.3.0-9b18abfd30-10c0.zip/node_modules/headers-polyfill/src/transformers/flattenHeadersObject.ts"],"sourcesContent":["\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n","export { Headers } from './Headers'\n\nexport { getRawHeaders } from './getRawHeaders'\nexport { headersToString } from './transformers/headersToString'\nexport { headersToList } from './transformers/headersToList'\nexport { headersToObject } from './transformers/headersToObject'\nexport { stringToHeaders } from './transformers/stringToHeaders'\nexport { listToHeaders } from './transformers/listToHeaders'\nexport { objectToHeaders } from './transformers/objectToHeaders'\n\nexport { reduceHeadersObject } from './transformers/reduceHeadersObject'\nexport { flattenHeadersList } from './transformers/flattenHeadersList'\nexport { flattenHeadersObject } from './transformers/flattenHeadersObject'\n\n/* Typings */\nexport {\n  HeadersList,\n  FlatHeadersList,\n  HeadersObject,\n  FlatHeadersObject,\n} from './glossary'\n","import { splitCookiesString } from 'set-cookie-parser'\nimport { HeadersList, HeadersObject } from './glossary'\nimport { normalizeHeaderName } from './utils/normalizeHeaderName'\nimport { normalizeHeaderValue } from './utils/normalizeHeaderValue'\nimport { isValidHeaderName } from './utils/isValidHeaderName'\nimport { isValidHeaderValue } from './utils/isValidHeaderValue'\n\nexport const NORMALIZED_HEADERS: unique symbol = Symbol('normalizedHeaders')\n\nexport const RAW_HEADER_NAMES: unique symbol = Symbol('rawHeaderNames')\n\nconst HEADER_VALUE_DELIMITER = ', ' as const\n\nexport class Headers {\n  // Normalized header {\"name\":\"a, b\"} storage.\n  private [NORMALIZED_HEADERS]: Record<string, string> = {}\n\n  // Keeps the mapping between the raw header name\n  // and the normalized header name to ease the lookup.\n  private [RAW_HEADER_NAMES]: Map<string, string> = new Map()\n\n  constructor(init?: HeadersInit | HeadersObject | HeadersList) {\n    /**\n     * @note Cannot check if the `init` is an instance of the `Headers`\n     * because that class is only defined in the browser.\n     */\n    if (\n      ['Headers', 'HeadersPolyfill'].includes(init?.constructor.name) ||\n      init instanceof Headers\n    ) {\n      const initialHeaders = init as Headers\n      initialHeaders.forEach((value, name) => {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(init)) {\n      init.forEach(([name, value]) => {\n        this.append(\n          name,\n          Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value\n        )\n      })\n    } else if (init) {\n      Object.getOwnPropertyNames(init).forEach((name) => {\n        const value = init[name]\n        this.append(\n          name,\n          Array.isArray(value) ? value.join(HEADER_VALUE_DELIMITER) : value\n        )\n      })\n    }\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  *keys(): IterableIterator<string> {\n    for (const [name] of this.entries()) {\n      yield name\n    }\n  }\n\n  *values(): IterableIterator<string> {\n    for (const [, value] of this.entries()) {\n      yield value\n    }\n  }\n\n  *entries(): IterableIterator<[string, string]> {\n    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n    let sortedKeys = Object.keys(this[NORMALIZED_HEADERS]).sort((a, b) =>\n      a.localeCompare(b)\n    )\n    for (const name of sortedKeys) {\n      if (name === 'set-cookie') {\n        for (const value of this.getSetCookie()) {\n          yield [name, value]\n        }\n      } else {\n        yield [name, this.get(name)]\n      }\n    }\n  }\n\n  /**\n   * Returns a boolean stating whether a `Headers` object contains a certain header.\n   */\n  has(name: string): boolean {\n    if (!isValidHeaderName(name)) {\n      throw new TypeError(`Invalid header name \"${name}\"`)\n    }\n\n    return this[NORMALIZED_HEADERS].hasOwnProperty(normalizeHeaderName(name))\n  }\n\n  /**\n   * Returns a `ByteString` sequence of all the values of a header with a given name.\n   */\n  get(name: string): string | null {\n    if (!isValidHeaderName(name)) {\n      throw TypeError(`Invalid header name \"${name}\"`)\n    }\n\n    return this[NORMALIZED_HEADERS][normalizeHeaderName(name)] ?? null\n  }\n\n  /**\n   * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  set(name: string, value: string): void {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    const normalizedValue = normalizeHeaderValue(value)\n\n    this[NORMALIZED_HEADERS][normalizedName] =\n      normalizeHeaderValue(normalizedValue)\n    this[RAW_HEADER_NAMES].set(normalizedName, name)\n  }\n\n  /**\n   * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.\n   */\n  append(name: string, value: string): void {\n    if (!isValidHeaderName(name) || !isValidHeaderValue(value)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    const normalizedValue = normalizeHeaderValue(value)\n\n    let resolvedValue = this.has(normalizedName)\n      ? `${this.get(normalizedName)}, ${normalizedValue}`\n      : normalizedValue\n\n    this.set(name, resolvedValue)\n  }\n\n  /**\n   * Deletes a header from the `Headers` object.\n   */\n  delete(name: string): void {\n    if (!isValidHeaderName(name)) {\n      return\n    }\n\n    if (!this.has(name)) {\n      return\n    }\n\n    const normalizedName = normalizeHeaderName(name)\n    delete this[NORMALIZED_HEADERS][normalizedName]\n    this[RAW_HEADER_NAMES].delete(normalizedName)\n  }\n\n  /**\n   * Traverses the `Headers` object,\n   * calling the given callback for each header.\n   */\n  forEach<ThisArg = this>(\n    callback: (\n      this: ThisArg,\n      value: string,\n      name: string,\n      parent: this\n    ) => void,\n    thisArg?: ThisArg\n  ) {\n    for (const [name, value] of this.entries()) {\n      callback.call(thisArg, value, name, this)\n    }\n  }\n\n  /**\n   * Returns an array containing the values\n   * of all Set-Cookie headers associated\n   * with a response\n   */\n  getSetCookie(): string[] {\n    const setCookieHeader = this.get('set-cookie')\n\n    if (setCookieHeader === null) {\n      return []\n    }\n\n    if (setCookieHeader === '') {\n      return ['']\n    }\n\n    return splitCookiesString(setCookieHeader)\n  }\n}\n","const HEADERS_INVALID_CHARACTERS = /[^a-z0-9\\-#$%&'*+.^_`|~]/i\n\nexport function normalizeHeaderName(name: string): string {\n  if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n\n  return name.trim().toLowerCase()\n}\n","const charCodesToRemove = [\n  String.fromCharCode(0x0a),\n  String.fromCharCode(0x0d),\n  String.fromCharCode(0x09),\n  String.fromCharCode(0x20),\n]\n\nconst HEADER_VALUE_REMOVE_REGEXP = new RegExp(\n  `(^[${charCodesToRemove.join('')}]|$[${charCodesToRemove.join('')}])`,\n  'g'\n)\n\n/**\n * Normalize the given header value.\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n */\nexport function normalizeHeaderValue(value: string): string {\n  const nextValue = value.replace(HEADER_VALUE_REMOVE_REGEXP, '')\n  return nextValue\n}\n","/**\n * Validate the given header name.\n * @see https://fetch.spec.whatwg.org/#header-name\n */\nexport function isValidHeaderName(value: unknown) {\n  if (typeof value !== 'string') {\n    return false\n  }\n\n  if (value.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i)\n\n    if (character > 0x7f || !isToken(character)) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isToken(value: string | number): boolean {\n  return ![\n    0x7f,\n    0x20,\n    '(',\n    ')',\n    '<',\n    '>',\n    '@',\n    ',',\n    ';',\n    ':',\n    '\\\\',\n    '\"',\n    '/',\n    '[',\n    ']',\n    '?',\n    '=',\n    '{',\n    '}',\n  ].includes(value)\n}\n","/**\n * Validate the given header value.\n * @see https://fetch.spec.whatwg.org/#header-value\n */\nexport function isValidHeaderValue(value: unknown): boolean {\n  if (typeof value !== 'string') {\n    return false\n  }\n\n  if (value.trim() !== value) {\n    return false\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const character = value.charCodeAt(i)\n\n    if (\n      // NUL.\n      character === 0x00 ||\n      // HTTP newline bytes.\n      character === 0x0a ||\n      character === 0x0d\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n","import { RAW_HEADER_NAMES } from './Headers'\n\n/**\n * Returns the object of all raw headers.\n */\nexport function getRawHeaders(headers: Headers) {\n  const rawHeaders: Record<string, string> = {}\n\n  for (const [name, value] of headers.entries()) {\n    rawHeaders[headers[RAW_HEADER_NAMES].get(name)] = value\n  }\n\n  return rawHeaders\n}\n","import { HeadersList } from '../glossary'\n\nexport function headersToList(headers: Headers): HeadersList {\n  const headersList: HeadersList = []\n\n  headers.forEach((value, name) => {\n    const resolvedValue = value.includes(',')\n      ? value.split(',').map((value) => value.trim())\n      : value\n\n    headersList.push([name, resolvedValue])\n  })\n\n  return headersList\n}\n","import { headersToList } from './headersToList'\n\n/**\n * Converts a given `Headers` instance to its string representation.\n */\nexport function headersToString(headers: Headers): string {\n  const list = headersToList(headers)\n  const lines = list.map(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n    return `${name}: ${values.join(', ')}`\n  })\n\n  return lines.join('\\r\\n')\n}\n","import { HeadersObject } from '../glossary'\n\n// List of headers that cannot have multiple values,\n// while potentially having a comma in their single value.\nconst singleValueHeaders = ['user-agent']\n\n/**\n * Converts a given `Headers` instance into a plain object.\n * Respects headers with multiple values.\n */\nexport function headersToObject(headers: Headers): HeadersObject {\n  const headersObject: HeadersObject = {}\n\n  headers.forEach((value, name) => {\n    const isMultiValue =\n      !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',')\n    headersObject[name] = isMultiValue\n      ? value.split(',').map((s) => s.trim())\n      : value\n  })\n\n  return headersObject\n}\n","import { Headers } from '../Headers'\n\n/**\n * Converts a string representation of headers (i.e. from XMLHttpRequest)\n * to a new `Headers` instance.\n */\nexport function stringToHeaders(str: string): Headers {\n  const lines = str.trim().split(/[\\r\\n]+/)\n\n  return lines.reduce((headers, line) => {\n    if (line.trim() === '') {\n      return headers\n    }\n\n    const parts = line.split(': ')\n    const name = parts.shift()\n    const value = parts.join(': ')\n    headers.append(name, value)\n\n    return headers\n  }, new Headers())\n}\n","import { Headers } from '../Headers'\nimport { HeadersList } from '../glossary'\n\nexport function listToHeaders(list: HeadersList): Headers {\n  const headers = new Headers()\n\n  list.forEach(([name, value]) => {\n    const values = ([] as string[]).concat(value)\n\n    values.forEach((value) => {\n      headers.append(name, value)\n    })\n  })\n\n  return headers\n}\n","import { HeadersObject } from '../glossary'\n\n/**\n * Reduces given headers object instnace.\n */\nexport function reduceHeadersObject<R>(\n  headers: HeadersObject,\n  reducer: (headers: R, name: string, value: string | string[]) => R,\n  initialState: R\n): R {\n  return Object.keys(headers).reduce<R>((nextHeaders, name) => {\n    return reducer(nextHeaders, name, headers[name])\n  }, initialState)\n}\n","import { Headers } from '../Headers'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\n/**\n * Converts a given headers object to a new `Headers` instance.\n */\nexport function objectToHeaders(\n  headersObject: Record<string, string | string[] | undefined>\n): Headers {\n  return reduceHeadersObject(\n    headersObject,\n    (headers, name, value) => {\n      const values = ([] as string[]).concat(value).filter(Boolean)\n\n      values.forEach((value) => {\n        headers.append(name, value)\n      })\n\n      return headers\n    },\n    new Headers()\n  )\n}\n","import { HeadersList, FlatHeadersList } from '../glossary'\n\nexport function flattenHeadersList(list: HeadersList): FlatHeadersList {\n  return list.map(([name, values]) => {\n    return [name, ([] as string[]).concat(values).join(', ')]\n  })\n}\n","import { HeadersObject, FlatHeadersObject } from '../glossary'\nimport { reduceHeadersObject } from './reduceHeadersObject'\n\nexport function flattenHeadersObject(\n  headersObject: HeadersObject\n): FlatHeadersObject {\n  return reduceHeadersObject<FlatHeadersObject>(\n    headersObject,\n    (headers, name, value) => {\n      headers[name] = ([] as string[]).concat(value).join(', ')\n      return headers\n    },\n    {}\n  )\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;AAAA;AAAA,SAAAA,yBAAAC,GAAA,EAAAC,CAAA;EAEA,IAAIC,EAAA,GAAAF,GAAA,eAAsB,UAAAG,MAAA,oBAAAH,GAAA,CAAAG,MAAA,CAAAC,QAAA,KAAAJ,GAAA;EAAA,IACxBE,EAAA,UAAc;EAAA,IACdG,IAAK;EAAA,IACLC,EAAA,OAAQ;EACV,IAAAC,EAAA;EAEA,IAAAC,EAAA,EAAAC,EAAS;EACP;IACF,KAAAP,EAAA,GAAAA,EAAA,CAAAQ,IAAA,CAAAV,GAAA,KAAAM,EAAA,IAAAE,EAAA,GAAAN,EAAA,CAAAS,IAAA,IAAAC,IAAA,GAAAN,EAAA;MAEAD,IAAS,CAAAQ,IAAA,CAAAL,EAAA,CAAYM,KAAA;MACf,IAAAb,CAAA,IAAQI,IAAA,CAAAU,MAAA,KAAed,CAAA,EAAM;IAEjC;EACA,SAAIe,GAAA;IACJT,EAAI,OAAO;IACXE,EAAI,GAAAO,GAAA;EAEJ;IAIA,IAAI;MACF,IAAQ,CAAAV,EAAA,IAAAJ,EAAQ,cAAe,MAAAA,EAAA,WAAmB;IACpD,UAAS;MACP,IAAQK,EAAA,QAAAE,EAAA;IAAA;EAGJ;EACF,OACFJ,IAAA;AAAA;AAGF,SAAAY,kBAAaA,CAAA;EAAA,MACX,IAAAC,SAAA;AAAA;AACA,SACFC,iBAAAnB,GAAA,EAAAC,CAAA;EAEA,OAAAmB,iBAAc,CAAUpB,GAAA,KAAMD,wBAAA,CAAAC,GAAA,EAAAC,CAAA,KAAAoB,8BAAA,CAAArB,GAAA,EAAAC,CAAA,KAAAgB,kBAAA;AAC5B;AACA,SAAAI,8BAAwBA,CAAAC,CAAS,EAAEC,MAAA;EACnC,KAAAD,CAAA,EAAI;EACJ,WAAIA,CAAA,KAAQ,UAAW,OAAAE,oBAAA,CAAAF,CAAA,EAAAC,MAAA;EACrB,IAAAE,CAAA,GAAAC,MAAO,CAAAC,SAAU,CAAAC,QAAS,CAAAlB,IAAK,CAAAY,CAAA,EAAAO,KAAA;EAAA,IACjCJ,CAAA,aAAW,IAAAH,CAAQ,CAAAQ,WAAW,EAAAL,CAAA,GAAAH,CAAA,CAAAQ,WAAA,CAAAC,IAAA;EAC5B,IAAAN,CAAA,UAAO,IAAAA,CAAA,KAAS,OAAS,OAAOO,KAAE,CAAAC,IAAA,CAAAR,CAAA;EAAA,IACpCA,CAAA,gBAAW,IAAQ,0CAAU,CAAAS,IAAA,CAAAT,CAAA,UAAAD,oBAAA,CAAAF,CAAA,EAAAC,MAAA;AAC3B;AAAgB,SAClBY,aAAWA,CAAAC,OAAQ,EAAAC,IAAA;EACjB,IAAAC,CAAA;IAAAC,CAAA;IAAAC,CAAA;IAAOC,CAAA;IAAAC,CAAA;MACTC,KAAA;MACEC,IAAA,WAAAA,CAAA,EAAO;QACT,IAAOJ,CAAA,eAAAA,CAAA;QACL,OAAOA,CAAG;MACZ;MACDK,IAAA;MAEDC,GAAA,EAAO;IACT;EAEA,OAAAL,CAAA,GAAS;IAGP9B,IAAI,EAAAoC,IAAO;IACX,OAAI,EAAAA,IAAQ;IACZ,QAAI,EAAAA,IAAA;EACJ,UAAI5C,MAAA,KAAa,UAAY,KAAAsC,CAAA,CAAAtC,MAAA,CAAAC,QAAA;IAC3B,OAAO;EACP,IAAAqC,CAAA;EAA6B,SACxBM,KAAAtB,CAAA;IACL,iBAAQuB,CAAA;MACV,OAAAC,IAAA,EAESxB,CAAA,EACXuB,CAAA,CAES;IACP;EAIA;EACE,SAAKC,KAAAC,EAAA,EAAQ;IACX,IAAAZ,CAAA,QAAQ,IAAApB,SAAA;IACV,OAAAwB,CAAO;MACL,IAAAJ,CAAO,GAAC,GAAAC,CAAA,KAAAC,CAAA,GAAAU,EAAA,UAAAX,CAAA,aAAAW,EAAA,MAAAX,CAAA,eAAAC,CAAA,GAAAD,CAAA,eAAAC,CAAA,CAAA9B,IAAA,CAAA6B,CAAA,QAAAA,CAAA,CAAA5B,IAAA,OAAA6B,CAAA,GAAAA,CAAA,CAAA9B,IAAA,CAAA6B,CAAA,EAAAW,EAAA,MAAAtC,IAAA,SAAA4B,CAAA;MACV,IAAAD,CAAA,MAAAC,CAAA,EAAAU,EAAA,IACFA,EAAA,SAEUV,CAAA,CAAA1B,KAAA,CACJ;MAGF,QAAQoC,EAAA,GAAM;QAChB,KAAW;QAET,KAAQ;UACHV,CAAA,GAAAU,EAAA;UAGH;QAEI,KAAO;UAEXR,CAAA,CAAAC,KAAA;UAEG,OAAO;YACF7B,KAAA,EAAAoC,EAAA;YACNtC,IAAA;UACF;QACF;UACQ8B,CAAA,CAAAC,KAAA;UACVJ,CAAA,GAAAW,EAAA;UACFA,EAAA,IACW,CAAQ,CACR;UACX;QAEU;UAIGA,EAAA,GAAKR,CAAA,CAAAI,GAAA,CAAAK,GAAA;UACTT,CAAM,CAAAG,IAAA,CAAAM,GAAO;UACX;QACR;UACI,MAAAX,CAAA,GAAAE,CAAA,CAAAG,IAAA,EAAAL,CAAA,GAAAA,CAAA,CAAAzB,MAAA,QAAAyB,CAAA,CAAAA,CAAA,CAAAzB,MAAA,WAAAmC,EAAA,aAAAA,EAAA;YACUR,CAAA;YACF;UACP;UACI,IAAAQ,EAAO,QAAQ,OAAAV,CAAA,IAAAU,EAAA,MAAAV,CAAA,OAAAU,EAAA,MAAAV,CAAA;YAChBE,CAAA,CAAAC,KAAA,GAAAO,EAAA;YACC;UACZ;UACF,IAAAA,EAAA,aAAAR,CAAA,CAAAC,KAAA,GAAAH,CAAA;YAaSE,CAAA,CAAAC,KAAA,GAAmBH,CAAA;YACRA,CAAA,GAAAU,EAAA;YACT;UACT;UACW,IAAAV,CAAA,IAAAE,CAAA,CAAAC,KAAkB,GAAAH,CAAA,KAAU;YAC7BE,CAAA,CAAAC,KAAA,GAAAH,CAAA;YACVE,CAAA,CAAAI,GAAA,CAAAjC,IAAA,CAAAqC,EAAA;YAEI;UACM;UACN,IAAAV,CAAA,KAAAE,CAAA,CAAAI,GAAA,CAAAK,GAAA;UACAT,CAAA,CAAAG,IAAA,CAAAM,GAAA;UACA;MACA;MACAD,EAAA,GAAAb,IAAA,CAAA3B,IAAA,CAAA0B,OAAA,EAAAM,CAAA;IAEJ,SAASU,CAAA;MACPF,EAAA,GAAO,CACL,CAAO,EACTE,CAAA,CACA;MACFb,CAAA;IAEA,UAAS;MACPD,CAAK,GAAAE,CAAA;IAEL;IACF,IAAAU,EAAA,eAAAA,EAAA;IAEA,OAAO;MACLpC,KAAQ,EAAAoC,EAAA,MAAAA,EAAA;MACRtC,IAAA;IAEA;EACE;AACA;AAEE,IAAAyC,QAAA,GAAA3B,MAAA,CAAA4B,MAAY;AACZ,IAAAC,SAAA,GAAA7B,MAAO,CAAA8B,cAAA;AAEP,IAAAC,gBAAA,GAAA/B,MAAe,CAAAgC,wBAAA;AACf,IAAAC,iBAAA,GAAYjC,MAAA,CAAAkC,mBAAA;AAEZ,IAAAC,YAAA,GAAOnC,MAAM,CAAAoC,cAAc;AACzB,IAAAC,YAAA,GAAArC,MAAO,CAAAC,SAAA,CAAAqC,cAAA;AAAA,IAAAC,UACT,YAAAA,CAAAC,EAAA,EAAAC,GAAA;EAGA,gBAAIC,SAAMA,CAAA;IAER,OAAAD,GAAA,QAAAD,EAAA,CAAAP,iBAAwB,CAAAO,EAAA,QAAAC,GAAA;MAExBE,OAAA,EAAM;IACN,GAAAA,OAAA,EAAAF,GAAA,GAAAA,GAAe,CAAAE,OAAK;EACpB;AAAQ;AAIR,IAAAC,QAAA,YAAAA,CAAMC,MAAA,EAAYC,GAAA;EAAA,SACpBzC,IAAA,IAAAyC,GAAA,EAAAjB,SAAA,CAAAgB,MAAA,EAAAxC,IAAA;IAAA0C,GACF,EAAAD,GAAA,CAAOzC,IAAA;IACL2C,UAAA,EAAO;EAAA;AACT;AAGF,IAAAC,WAAK,YAAAA,CAAAC,EAAA,EAAA3C,IAAA,EAAA4C,MAAyB,EAAOC,IAAA;EACnC,IAAA7C,IAAA,WAAAA,IAAe,KAAK,YAAc,OAAAA,IAAU,eAAO;IACrD,IAAA8C,yBAAA;MAAAC,iBAAA;MAAAC,cAAA,GAAAC,SAAA;IACF;MAEA,IAAOC,KAAA,YAAAA,CAAA;QACT,IAAAC,GAAA,GAAAC,KAAA,CAAAvE,KAAA;QAEO,KAAAiD,YAAU,CAAArD,IAAA,CAAAkE,EAAA,EAAAQ,GAAA,KAAAA,GAAA,KAAAP,MAAA,EAAAtB,SAAA,CAAAqB,EAAA,EAAAQ,GAAA;UACFX,GAAA,WAAAA,CAAA,EAAQ;YACR,OAAAxC,IAAc,CAAAmD,GAAA;UACd;UAAqBV,UAAA,IAAAI,IAAA,GAAArB,gBAAA,CAAAxB,IAAA,EAAAmD,GAAA,MAAAN,IAAA,CAAAJ;QAAA;;;ICjOpC,SAAA1D,GAAA;MAAAgE,iBAAA;MAAAC,cAAA,GAAAjE,GAAA;IAAA;MAAA;QAAA,KAAA+D,yBAAA,IAAAO,SAAA,CAAAC,MAAA;UAAAD,SAAA,CAAAC,MAAA;QAAA;MAAA;QAAA,IAAAP,iBAAA;UAAA,MAAAC,cAAA;QAAA;MAAA;IAAA;EAAA;;;ACAA,IAAAO,OAAA,YAAAA,CAAArB,GAAA,EAAAsB,UAAmC,EAAAlB,MAAA;;;;ECA7B;EAEC;EACLkB,UAAI,KAAAtB,GAAA,KAAAA,GAAA,CAAAuB,UAAgC,GAAInC,SAAU,CAAAgB,MAAK,WAAU;IAC/DzD,KAAM,EAAIqD,GAAA;IACZO,UAAA;EAEA,KAAOH,MAAK,EAAAJ,GAAK,CAAE;AACrB;;;ICRMrD,KAAA;EACJ,IAAAqD,GAAO;AAAiB;AACA;AACA,IACxBwB,kBAAoB,GAAI1B,UAAA;EAC1B,6DAAA2B,CAAAvB,OAAA,EAAAwB,OAAA;IAEM;;IACE,IAAAC,gBAAkB,GAAK,SAAGA,gBAAOA,CAAAC,GAAkB;MACzD,cAAAA,GAAA,mBAAAA,GAAA,CAAAC,IAAA;IACF;IAMO,IAASC,WAAA,YAAqBA,WAAuBA,CAAAC,cAAA,EAAAC,OAAA;MACpD,IAAAC,KAAY,GAAAF,cAAc,CAAAG,KAAA,MAAAC,MAAA,CAAAR,gBAA8B;MACvD,IAAAS,gBAAA,GAAAH,KAAA,CAAAI,KAAA;MACT,IAAAC,MAAA,GAAAC,kBAAA,CAAAH,gBAAA;;;MCfgBJ,OAAA,GAAAA,OAAkB,GAAAzE,MAAgB,CAAAiF,MAAA,KAAAC,mBAAA,EAAAT,OAAA,IAAAS,mBAAA;MAC5C,IAAO;QACF9F,KAAA,GAAAqF,OAAA,CAAAU,YAAA,GAAAC,kBAAA,CAAAhG,KAAA,IAAAA,KAAA;MACT,SAAAsC,CAAA;QAEU2D,OAAW,CAAAC,KAAG,iFAAAlG,KAAA,oEAAAsC,CAAA;MACf;MACT,IAAA6D,MAAA;QAEalF,IAAG,EAAIA,IAAA;QACZjB,KAAA,EAAYA;MAEd;MACFsF,KAAO,CAAAc,OAAA,WAAAC,IAAA;QACT,IAAAC,KAAA,GAAAD,IAAA,CAAAd,KAAA;QACF,IAAAjB,GAAA,GAAAgC,KAAA,CAAAZ,KAAA,GAAAa,QAAA,GAAAC,WAAA;QAEO,IAAAC,MAAA,GAAAH,KAAA,CAAAI,IAAA;QACT,IAAApC,GAAA;UAEiB6B,MAAiC,CAAAQ,OAAA,OAAAC,IAAA,CAAAH,MAAA;QACxC,WAAAnC,GAAA;UACN6B,MAAA,CAAAU,MAAA,GAAAC,QAAA,CAAAL,MAAA;QACA,WAAAnC,GAAA;UACA6B,MAAA,CAAAY,MAAA;QACA,WAAAzC,GAAA;UACA6B,MAAA,CAAAa,QAAA;QACA,WAAA1C,GAAA;UACA6B,MAAA,CAAAc,QAAA,GAAAR,MAAA;QACA;UACAN,MAAA,CAAA7B,GAAA,IAAAmC,MAAA;QACA;MACA;MACA,OAAAN,MAAA;IACA;IACA,IAAAP,kBAAA,YAAAA,mBAAAH,gBAAA;MACA,IAAAxE,IAAA;MACA,IAAAjB,KAAA;MACA,IAAAkH,YAAA,GAAAzB,gBAAA,CAAAF,KAAA;MACA,IAAA2B,YAAA,CAAAjH,MAAA;QACAgB,IAAA,GAAAiG,YAAA,CAAAxB,KAAA;QACS1F,KAAK,GAAAkH,YAAA,CAAAR,IAAA;MAClB;;;MC1CgB;QACHzF,IAAA,EAAAA,IAAU;QACZjB,KAAA,EAAAA;MACT;IAEI;IACF,IAAOmH,KAAA,YAAAA,MAAAC,KAAA,EAAA/B,OAAA;MACTA,OAAA,GAAAA,OAAA,GAAAzE,MAAA,CAAAiF,MAAA,KAAAC,mBAAA,EAAAT,OAAA,IAAAS,mBAAA;MAES,IAAI,CAAAsB,KAAO;QACZ,KAAA/B,OAAkB,CAAAgC,GAAA;UAExB;QAAA;UAEgB;QAEd;MAEA;MACA,IAAOD,KAAA,CAAAE,OAAA;QACT,WAAAF,KAAA,CAAAE,OAAA,CAAAC,YAAA;UACFH,KAAA,GAAAA,KAAA,CAAAE,OAAA,CAAAC,YAAA;QAEO,WAAAH,KAAA,CAAAE,OAAA;UACTF,KAAA,GAAAA,KAAA,CAAAE,OAAA;;;YJrBa,OAAoChD,GAAO,CAAAkC,WAAA,OAAmB;UAE9D,GAAkC;UAEzC,KAAAgB,GAAA,IAAyBJ,KAAA,CAAAE,OAAA,CAAAnB,MAAA,KAAAd,OAAA,CAAAoC,MAAA;YAX/BxB,OAAA,CAAAyB,IAAA;UAaa;UAQmDN,KAAA,GAAAI,GAAA;QAN9D;MAAS;MAIT,KAAAtG,KAAA,CAAAyG,OAAA,CAAAP,KAAA;QAAAA,KAAA,IAAkDA,KAAA,CAQ7C;MAGK;MACN/B,OAAA,GAAeA,OAAQ,GAACzE,MAAO,CAAAiF,MAAA,CAAS,IAAAC,mBAAA,EAAAT,OAAA,IAAAS,mBAAA;MACtC,IAAK,CAAAT,OAAO,CAAAgC,GAAM;QACb,OAAAD,KAAA,CAAA5B,MAAA,CAAAR,gBAAA,EAAAqC,GAAA,WAAApC,GAAA;UACE,OAAME,WAAe,CAAAF,GAAA,EAAAI,OAAA;QACzB;MACH,CAAK;QACH,IAAAuC,OAAA;QACM,OAAAR,KAAQ,CAAK5B,MAAI,CAAAR,gBAAW,EAAA6C,MAAA,WAA0BC,QAAA,EAAA7C,GAAA;UAC9D,IAAAkB,MAAA,GAAAhB,WAAA,CAAAF,GAAA,EAAAI,OAAA;UACDyC,QAAA,CAAA3B,MAAA,CAAAlF,IAAA,IAAAkF,MAAA;UACQ,OAAM2B,QAAA;QACR,GAAAF,OAAA;MACL;IACA;IAAK,IACHG,mBAAA,YAAAA,oBAAAC,aAAA;MACA,IAAM9G,KAAA,CAAAyG,OAAa,CAAAK,aAAU,CAAK;QACpC,OAAAA,aAAA;MACD;MACH,WAAAA,aAAA;QACF;MAnCS;MAsCA,IAAKC,cAAQ;MACtB,IAAAC,GAAA;MAEkC,IAAAC,KAAA;MAChC,IAAYC,EAAA;MACJ,IAAAC,SAAA;MACR,IAAAC,SAAA;MACF,IAAAC,qBAAA;MAEoC,SAAAC,eAAA;QACtB,OAAEN,GAAK,GAAKF,aAAa,CAAA/H,MAAG,SAAAmB,IAAA,CAAA4G,aAAA,CAAAS,MAAA,CAAAP,GAAA;UAChCA,GAAA;QACR;QACF,OAAAA,GAAA,GAAAF,aAAA,CAAA/H,MAAA;MAEC;MAEK,SAAayI,cAAYA,CAAA,EAAK;QAChCN,EAAE,GAAAJ,aAAe,CAAAS,MAAA,CAAAP,GAAA;QACnB,OAAAE,EAAA,YAAAA,EAAA,YAAAA,EAAA;MACA;MACM,OAAAF,GAAS,GAAAF,aAAc,CAAA/H,MAAA;QACzBkI,KAAW,GAAAD,GAAA;QACHK,qBAAY;QACpB,OAAAC,cAAA;UACKJ,EAAA,GAAAJ,aAAA,CAAAS,MAAA,CAAAP,GAAA;UACE,IAAME,EAAK,KAAI,GAAI,EAAC;YAC7BC,SAAA,GAAAH,GAAA;YACFA,GAAA;YACFM,cAAA;YAAAF,SAAA,GAAAJ,GAAA;YAAA,OAAAA,GAAA,GAAAF,aAAA,CAAA/H,MAAA,IAAAyI,cAAA;cAAAR,GAAA;YAK2B;YACpB,IAAkBA,GAAI,GAAGF,aAAA,CAAA/H,MAAA,IAAA+H,aAAA,CAAAS,MAAA,CAAAP,GAAA;cACRK,qBAAA,GAAwB,IAAI;cAClDL,GAAA,GAAAI,SAAA;cAEYL,cAAoB,CAAAlI,IAAA,CAAAiI,aAAe,CAAAW,SAAoB,CAAAR,KAAK,EAAAE,SAAA;cAC1EF,KAAA,GAAAD,GAAA;YAAA;cAAAA,GAAA,GAAAG,SAAA;YAAA;UAKiC;YAC1BH,GAAkB,IAAI;UACnB;QACR;QAEY,KAAAK,qBAAoB,IAAAL,GAAA,IAAAF,aAA8B,CAAA/H,MAAA;UAChEgI,cAAA,CAAAlI,IAAA,CAAAiI,aAAA,CAAAW,SAAA,CAAAR,KAAA,EAAAH,aAAA,CAAA/H,MAAA;QAAA;MAAA;MAAA,OAAAgI,cAAA;IAKI;IACE,IAACnC,mBAAsB;MACzBC,YAAA;MACFsB,GAAA;MAEMI,MAAA;IACN;IAEA1C,OAAK,CAAAxB,OAAA,GAAA4D,KAAoB;IAEzBpC,OAAK,CAAAxB,OAAA,CAAA4D,KAAkB,GAAIA,KAAA;IAC7BpC,OAAA,CAAAxB,OAAA,CAAA4B,WAAA,GAAAA,WAAA;IAAAJ,OAAA,CAAAxB,OAAA,CAAAqF,kBAAA,GAAAb,mBAAA;EAAA;AAAA;AAAA;AAME,IAAAc,WAAK;AACHrF,QAAA,CAAAqF,WAAA;EACFC,OAAA,WAAAA,CAAA;IAEA,OAAMA,OAAA;EACN;EAEAC,kBAAI,EAAgB,SAAAA,CAAA,EAAS;IAI7B,OAASA,kBAAmB;EAC9B;EAAAC,oBAAA,WAAAA,CAAA;IAAA,OAAAA,oBAAA;EAAA;EAKAC,aAA2B,WAAAA,CAAA;IACrB,OAACA,aAAkB;EACrB;EACFC,aAAA,WAAAA,CAAA;IAEI,OAAMA,aAAW;EACnB;EACFC,eAAA,WAAAA,CAAA;IAEA,OAAMA,eAAiB;EACvB;EACAC,eAAK,WAAAA,CAAA,EAAkB;IACzB,OAAAA,eAAA;EAAA;EAAAC,aAAA,WAAAA,CAAA;IAAA,OAAAA,aAAA;EAAA;EAMAC,eACE,EAMA,SAAAA,CAAA,EACA;IACA,OAAWA,eAAY;EACrB;EACFC,mBAAA,WAAAA,CAAA;IACF,OAAAA,mBAAA;EAAA;EAAAC,eAAA,WAAAA,CAAA;IAAA,OAAAA,eAAA;EAAA;AAAA;AAAAC,MAOA,CAAAlG,OAAA,GAAyBmG,YAAA,CAAAb,WAAA;AACvB;AAEA,IAAAc,wBAAwB,GAAAjF,OAAM,CAAAG,kBAAA;AAC5B;AAAQ,IACV+E,0BAAA;AAEA,SAAIC,mBAAoBA,CAAA5I,IAAI;EAC1B,IAAA2I,0BAAU,CAAAxI,IAAA,CAAAH,IAAA,KAAAA,IAAA,CAAAiE,IAAA;IACZ,UAAA9E,SAAA;EAEA;EACF,OAAAa,IAAA,CAAAiE,IAAA,GAAAsB,WAAA;AACF;;yBK5LOsD,MAAS,CAAAC,YAAc,MAC5BD,MAAM,CAAAC,YAAsC,MAE5CD,MAAA,CAAAC,YAAkB,EAAK,GACrBD,MAAA,CAAAC,YAAmB,KAA+B;AAGpD,IAAAC,0BAAO,OAAAC,MAAA,OAAAC,MAAA,CAAAC,iBAAA,CAAAzD,IAAA,cAAAwD,MAAA,CAAAC,iBAAA,CAAAzD,IAAA;AACT,SAAA0D,qBAAApK,KAAA;;;ACXO;AACL;AAEA,SAAAqK,iBAAwBA,CAAArK,KAAA;EACtB,WAAMA,KAAA,aAAsB;IAI5B,YAAY;EACb;EAED,IAAAA,KAAO,CAAAC,MAAA;IACT;;;ICTO,IAASqK,SAAA,GAAAtK,KAAgB,CAAAuK,UAA0B,CAAApL,CAAA;IAClD,IAAAmL,SAAO,UAAc,CAAAE,OAAO,CAAAF,SAAA;MAC5B,OAAQ,KAAK;IACjB;EACA;EACD;AAED;AACF,SAAAE,QAAAxK,KAAA;gBCTM,IAMC,GAAS,EACR,KAEN,GAAQ,EACN,GAAM,EAEN,KAGD,KAED,GAAO,EACT,K,WChBO,GAAS,EACR,KAEN,GAAO,EACD,KACF,KACF,KAEA,GAAM,CACN,CAAAyK,QAAM,CAAAzK,KAAO;AACb;AACA;AAEA,SAAA0K,kBAAOA,CAAA1K,KAAA;EACT,IAAG,OAAIA,KAAS;IAClB;;;IClBO,OAAS;EACd;EAEA,KAAK,IAAAb,CAAA,GAAS,CAAC,EAAAA,CAAA,GAAMa,KAAK,CAAAC,MAAM,EAAAd,CAAA;IAC9B,IAAMmL,SAAW,GAAetK,KAAO,CAAAuK,UAAK,CAAApL,CAAA;IAE5C;IAAO;IACLmL,SAAQ,KAAO;IAAM;IACtBA,SAAA,WAAAA,SAAA;MACF;IAED;EACF;;;ACVO;AAKL,IAAAK,kBAAmB,GAAAtL,MAAS,oBAAwB;AAClD,IAAAuL,gBAAe,GAAAvL,MAAA,iBAA2B;AAAK,IACjDwL,sBAAe;AACjB,IAAAC,EAAA,EAAAC,EAAA;;;;ECPO,SAASC,SAAAC,IACd;IAEA,IAAOC,KAAA;IACLC,iBAAA,OAAAH,QAAA;IACC,IAAAI,KAAS;IACR;IAEA,KAAON,EAAA,MAAQ;IACb;IACD;IAED,KAAOC,EAAA,uBAAAM,GAAA;IACT,KACI,SAAQ,EACd,kBACF,CAAAZ,QAAA,EAAAW,KAAA,GAAAH,IAAA,cAAAG,KAAA,uBAAAA,KAAA,CAAApK,WAAA,CAAAC,IAAA,KAAAqK,WAAA,CAAAL,IAAA,EAAAD,QAAA;;;QCpBgBE,KAAA,CAAAK,MAAmB,CAAAtK,IAAA,EAAoCjB,KAAA;MAC9D,GAAK,IAAK,CAAC;IAChB,OAAQ,IAAQkB,KAAe,CAAAyG,OAAO,CAAAsD,IAAQ;MAC/CA,IAAA,CAAA7E,OAAA,WAAAoF,KAAA;QACH,IAAAC,MAAA,GAAApL,gBAAA,CAAAmL,KAAA;UAAAvK,IAAA,GAAAwK,MAAA;UAAAzL,KAAA,GAAAyL,MAAA;;;ICHO,CAAS,UAAAR,IAAA;MAGPrK,MAAA,CAAAkC,mBAAA,CAAAmI,IAAA,EAAA7E,OAAA,WAAAnF,IAAA;QACL,IAAAjB,KAAA,GAAAiL,IAAA,CAAAhK,IAAA;QACUiK,KAAM,CAAAK,MAAA,CAAAtK,IAAU,EAAAC,KAAA,CAAAyG,OAAA,CAAA3H,KAAA,IAAAA,KAAA,CAAA0G,IAAA,CAAAmE,sBAAA,IAAA7K,KAAA;MACxB,EAAQ;IACR;EACF;EACA0L,aAAC,CAAAV,QAAA,GACH;IACF1G,GAAA,GAAAwG,EAAA,GAAAH,kBAAA,EAAAI,EAAA,GAAAH,gBAAA,EAAAvL,MAAA,CAAAC,QAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}