{"ast":null,"code":"var __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { isNodeProcess } from \"is-node-process\";\nconst SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nconst MIN_SERVER_RESPONSE_TIME = 100;\nconst MAX_SERVER_RESPONSE_TIME = 400;\nconst NODE_SERVER_RESPONSE_TIME = 5;\nfunction getRealisticResponseTime() {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n}\nfunction delay(durationOrMode) {\n  return __async(this, null, function* () {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRealisticResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number.`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRealisticResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n      delayTime = durationOrMode;\n    }\n    return new Promise(resolve => setTimeout(resolve, delayTime));\n  });\n}\nexport { MAX_SERVER_RESPONSE_TIME, MIN_SERVER_RESPONSE_TIME, NODE_SERVER_RESPONSE_TIME, SET_TIMEOUT_MAX_ALLOWED_INT, delay };","map":{"version":3,"names":["__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","throw","x","done","then","apply","isNodeProcess","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRealisticResponseTime","Math","floor","random","delay","durationOrMode","delayTime","Error","setTimeout"],"sources":["/Users/leeyangie/Documents/GitHub/BiteNest/biteNest/src/main/frontend/.yarn/unplugged/msw-virtual-7370ac2e06/node_modules/msw/lib/core/delay.mjs"],"sourcesContent":["var __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { isNodeProcess } from \"is-node-process\";\nconst SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nconst MIN_SERVER_RESPONSE_TIME = 100;\nconst MAX_SERVER_RESPONSE_TIME = 400;\nconst NODE_SERVER_RESPONSE_TIME = 5;\nfunction getRealisticResponseTime() {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME\n  );\n}\nfunction delay(durationOrMode) {\n  return __async(this, null, function* () {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\": {\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n          break;\n        }\n        case \"real\": {\n          delayTime = getRealisticResponseTime();\n          break;\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number.`\n          );\n        }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRealisticResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`\n        );\n      }\n      delayTime = durationOrMode;\n    }\n    return new Promise((resolve) => setTimeout(resolve, delayTime));\n  });\n}\nexport {\n  MAX_SERVER_RESPONSE_TIME,\n  MIN_SERVER_RESPONSE_TIME,\n  NODE_SERVER_RESPONSE_TIME,\n  SET_TIMEOUT_MAX_ALLOWED_INT,\n  delay\n};\n"],"mappings":"AAAA,IAAIA,OAAO,GAAGA,CAACC,MAAM,EAAEC,WAAW,EAAEC,SAAS,KAAK;EAChD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,IAAIC,SAAS,GAAIC,KAAK,IAAK;MACzB,IAAI;QACFC,IAAI,CAACN,SAAS,CAACO,IAAI,CAACF,KAAK,CAAC,CAAC;MAC7B,CAAC,CAAC,OAAOG,CAAC,EAAE;QACVL,MAAM,CAACK,CAAC,CAAC;MACX;IACF,CAAC;IACD,IAAIC,QAAQ,GAAIJ,KAAK,IAAK;MACxB,IAAI;QACFC,IAAI,CAACN,SAAS,CAACU,KAAK,CAACL,KAAK,CAAC,CAAC;MAC9B,CAAC,CAAC,OAAOG,CAAC,EAAE;QACVL,MAAM,CAACK,CAAC,CAAC;MACX;IACF,CAAC;IACD,IAAIF,IAAI,GAAIK,CAAC,IAAKA,CAAC,CAACC,IAAI,GAAGV,OAAO,CAACS,CAAC,CAACN,KAAK,CAAC,GAAGJ,OAAO,CAACC,OAAO,CAACS,CAAC,CAACN,KAAK,CAAC,CAACQ,IAAI,CAACT,SAAS,EAAEK,QAAQ,CAAC;IAChGH,IAAI,CAAC,CAACN,SAAS,GAAGA,SAAS,CAACc,KAAK,CAAChB,MAAM,EAAEC,WAAW,CAAC,EAAEQ,IAAI,CAAC,CAAC,CAAC;EACjE,CAAC,CAAC;AACJ,CAAC;AACD,SAASQ,aAAa,QAAQ,iBAAiB;AAC/C,MAAMC,2BAA2B,GAAG,UAAU;AAC9C,MAAMC,wBAAwB,GAAG,GAAG;AACpC,MAAMC,wBAAwB,GAAG,GAAG;AACpC,MAAMC,yBAAyB,GAAG,CAAC;AACnC,SAASC,wBAAwBA,CAAA,EAAG;EAClC,IAAIL,aAAa,CAAC,CAAC,EAAE;IACnB,OAAOI,yBAAyB;EAClC;EACA,OAAOE,IAAI,CAACC,KAAK,CACfD,IAAI,CAACE,MAAM,CAAC,CAAC,IAAIL,wBAAwB,GAAGD,wBAAwB,CAAC,GAAGA,wBAC1E,CAAC;AACH;AACA,SAASO,KAAKA,CAACC,cAAc,EAAE;EAC7B,OAAO5B,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,aAAa;IACtC,IAAI6B,SAAS;IACb,IAAI,OAAOD,cAAc,KAAK,QAAQ,EAAE;MACtC,QAAQA,cAAc;QACpB,KAAK,UAAU;UAAE;YACfC,SAAS,GAAGV,2BAA2B;YACvC;UACF;QACA,KAAK,MAAM;UAAE;YACXU,SAAS,GAAGN,wBAAwB,CAAC,CAAC;YACtC;UACF;QACA;UAAS;YACP,MAAM,IAAIO,KAAK,CACb,mDAAmDF,cAAc,8FACnE,CAAC;UACH;MACF;IACF,CAAC,MAAM,IAAI,OAAOA,cAAc,KAAK,WAAW,EAAE;MAChDC,SAAS,GAAGN,wBAAwB,CAAC,CAAC;IACxC,CAAC,MAAM;MACL,IAAIK,cAAc,GAAGT,2BAA2B,EAAE;QAChD,MAAM,IAAIW,KAAK,CACb,wDAAwDF,cAAc,4DAA4DT,2BAA2B,6NAC/J,CAAC;MACH;MACAU,SAAS,GAAGD,cAAc;IAC5B;IACA,OAAO,IAAIxB,OAAO,CAAEC,OAAO,IAAK0B,UAAU,CAAC1B,OAAO,EAAEwB,SAAS,CAAC,CAAC;EACjE,CAAC,CAAC;AACJ;AACA,SACER,wBAAwB,EACxBD,wBAAwB,EACxBE,yBAAyB,EACzBH,2BAA2B,EAC3BQ,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}