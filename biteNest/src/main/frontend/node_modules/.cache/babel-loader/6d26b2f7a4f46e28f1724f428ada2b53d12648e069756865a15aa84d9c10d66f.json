{"ast":null,"code":"import { until } from \"@open-draft/until\";\nimport { getResponse } from './getResponse.mjs';\nimport { onUnhandledRequest } from './request/onUnhandledRequest.mjs';\nimport { readResponseCookies } from './request/readResponseCookies.mjs';\nasync function handleRequest(request, requestId, handlers, options, emitter, handleRequestOptions) {\n  emitter.emit(\"request:start\", {\n    request,\n    requestId\n  });\n  if (request.headers.get(\"x-msw-intention\") === \"bypass\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const lookupResult = await until(() => {\n    return getResponse({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext\n    });\n  });\n  if (lookupResult.error) {\n    emitter.emit(\"unhandledException\", {\n      error: lookupResult.error,\n      request,\n      requestId\n    });\n    throw lookupResult.error;\n  }\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", {\n      request,\n      requestId\n    });\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const {\n    response\n  } = lookupResult.data;\n  if (!response) {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  if (response.status === 302 && response.headers.get(\"x-msw-intention\") === \"passthrough\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  readResponseCookies(request, response);\n  emitter.emit(\"request:match\", {\n    request,\n    requestId\n  });\n  const requiredLookupResult = lookupResult.data;\n  const transformedResponse = handleRequestOptions?.transformResponse?.(response) || response;\n  handleRequestOptions?.onMockedResponse?.(transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", {\n    request,\n    requestId\n  });\n  return transformedResponse;\n}\nexport { handleRequest };","map":{"version":3,"names":["until","getResponse","onUnhandledRequest","readResponseCookies","handleRequest","request","requestId","handlers","options","emitter","handleRequestOptions","emit","headers","get","onPassthroughResponse","lookupResult","resolutionContext","error","data","response","status","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse"],"sources":["/Users/leeyangie/Documents/GitHub/BiteNest/biteNest/src/main/frontend/.yarn/unplugged/msw-virtual-c17a34f746/node_modules/msw/src/core/utils/handleRequest.ts"],"sourcesContent":["import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: Response): Response\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-intention') === 'bypass') {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return getResponse({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as Response)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', { request, requestId })\n\n  return transformedResponse\n}\n"],"mappings":"AAAA,SAASA,KAAA,QAAa;AAKtB,SAA+BC,WAAA,QAAmB;AAClD,SAASC,kBAAA,QAA0B;AACnC,SAASC,mBAAA,QAA2B;AAqCpC,eAAsBC,cACpBC,OAAA,EACAC,SAAA,EACAC,QAAA,EACAC,OAAA,EACAC,OAAA,EACAC,oBAAA,EAC+B;EAC/BD,OAAA,CAAQE,IAAA,CAAK,iBAAiB;IAAEN,OAAA;IAASC;EAAU,CAAC;EAGpD,IAAID,OAAA,CAAQO,OAAA,CAAQC,GAAA,CAAI,iBAAiB,MAAM,UAAU;IACvDJ,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBI,qBAAA,GAAwBT,OAAO;IACrD;EACF;EAGA,MAAMU,YAAA,GAAe,MAAMf,KAAA,CAAM,MAAM;IACrC,OAAOC,WAAA,CAAY;MACjBI,OAAA;MACAC,SAAA;MACAC,QAAA;MACAS,iBAAA,EAAmBN,oBAAA,EAAsBM;IAC3C,CAAC;EACH,CAAC;EAED,IAAID,YAAA,CAAaE,KAAA,EAAO;IAEtBR,OAAA,CAAQE,IAAA,CAAK,sBAAsB;MACjCM,KAAA,EAAOF,YAAA,CAAaE,KAAA;MACpBZ,OAAA;MACAC;IACF,CAAC;IACD,MAAMS,YAAA,CAAaE,KAAA;EACrB;EAIA,IAAI,CAACF,YAAA,CAAaG,IAAA,EAAM;IACtB,MAAMhB,kBAAA,CAAmBG,OAAA,EAASE,QAAA,EAAUC,OAAA,CAAQN,kBAAkB;IACtEO,OAAA,CAAQE,IAAA,CAAK,qBAAqB;MAAEN,OAAA;MAASC;IAAU,CAAC;IACxDG,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBI,qBAAA,GAAwBT,OAAO;IACrD;EACF;EAEA,MAAM;IAAEc;EAAS,IAAIJ,YAAA,CAAaG,IAAA;EAIlC,IAAI,CAACC,QAAA,EAAU;IACbV,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBI,qBAAA,GAAwBT,OAAO;IACrD;EACF;EAIA,IACEc,QAAA,CAASC,MAAA,KAAW,OACpBD,QAAA,CAASP,OAAA,CAAQC,GAAA,CAAI,iBAAiB,MAAM,eAC5C;IACAJ,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBI,qBAAA,GAAwBT,OAAO;IACrD;EACF;EAGAF,mBAAA,CAAoBE,OAAA,EAASc,QAAQ;EAErCV,OAAA,CAAQE,IAAA,CAAK,iBAAiB;IAAEN,OAAA;IAASC;EAAU,CAAC;EAEpD,MAAMe,oBAAA,GACJN,YAAA,CAAaG,IAAA;EAEf,MAAMI,mBAAA,GACJZ,oBAAA,EAAsBa,iBAAA,GAAoBJ,QAAQ,KACjDA,QAAA;EAEHT,oBAAA,EAAsBc,gBAAA,GACpBF,mBAAA,EACAD,oBACF;EAEAZ,OAAA,CAAQE,IAAA,CAAK,eAAe;IAAEN,OAAA;IAASC;EAAU,CAAC;EAElD,OAAOgB,mBAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}