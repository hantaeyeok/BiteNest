{"ast":null,"code":"import jsLevenshtein from \"@bundled-es-modules/js-levenshtein\";\nimport { HttpHandler, GraphQLHandler } from '../../index.mjs';\nimport { parseGraphQLRequest } from '../internal/parseGraphQLRequest.mjs';\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest.mjs';\nimport { isStringEqual } from '../internal/isStringEqual.mjs';\nimport { devUtils } from '../internal/devUtils.mjs';\nconst getStringMatchScore = jsLevenshtein;\nconst MAX_MATCH_SCORE = 3;\nconst MAX_SUGGESTION_COUNT = 4;\nconst TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof HttpHandler) {\n      groups.http.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    http: [],\n    graphql: []\n  });\n}\nfunction getHttpHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = getStringMatchScore(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = getStringMatchScore(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nasync function onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  const parsedGraphQLQuery = await parseGraphQLRequest(request).catch(() => null);\n  const publicUrl = getPublicUrlFromRequest(request);\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.http;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getHttpHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function getGraphQLRequestHeader(parsedGraphQLRequest) {\n    if (!parsedGraphQLRequest?.operationName) {\n      return `anonymous ${parsedGraphQLRequest?.operationType} (${request.method} ${publicUrl})`;\n    }\n    return `${parsedGraphQLRequest.operationType} ${parsedGraphQLRequest.operationName} (${request.method} ${publicUrl})`;\n  }\n  function generateUnhandledRequestMessage() {\n    const requestHeader = parsedGraphQLQuery ? getGraphQLRequestHeader(parsedGraphQLQuery) : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`intercepted a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\nexport { onUnhandledRequest };","map":{"version":3,"names":["jsLevenshtein","HttpHandler","GraphQLHandler","parseGraphQLRequest","getPublicUrlFromRequest","isStringEqual","devUtils","getStringMatchScore","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groupHandlersByType","handlers","reduce","groups","handler","http","push","graphql","getHttpHandlerScore","request","path","method","info","RegExp","Infinity","hasSameMethod","methodScoreDelta","requestPublicUrl","score","getGraphQLHandlerScore","parsedQuery","_","operationName","operationType","hasSameOperationType","operationTypeScoreDelta","getSuggestedHandler","getScore","suggestedHandlers","suggestions","concat","sort","leftScore","rightScore","filter","slice","map","getSuggestedHandlersMessage","length","header","join","onUnhandledRequest","strategy","parsedGraphQLQuery","catch","publicUrl","generateHandlerSuggestion","handlerGroups","relevantHandlers","getGraphQLRequestHeader","parsedGraphQLRequest","generateUnhandledRequestMessage","requestHeader","handlerSuggestion","messageTemplate","Boolean","applyStrategy","strategy2","message","error","Error","formatMessage","warn","warning","bind"],"sources":["/Users/leeyangie/Documents/GitHub/BiteNest/biteNest/src/main/frontend/.yarn/unplugged/msw-virtual-c17a34f746/node_modules/msw/src/core/utils/request/onUnhandledRequest.ts"],"sourcesContent":["import jsLevenshtein from '@bundled-es-modules/js-levenshtein'\nimport { RequestHandler, HttpHandler, GraphQLHandler } from '../..'\nimport {\n  ParsedGraphQLQuery,\n  ParsedGraphQLRequest,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { devUtils } from '../internal/devUtils'\n\nconst getStringMatchScore = jsLevenshtein\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: Request,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  http: Array<HttpHandler>\n  graphql: Array<GraphQLHandler>\n}\n\nfunction groupHandlersByType(\n  handlers: Array<RequestHandler>,\n): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof HttpHandler) {\n        groups.http.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      http: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: Request,\n  handler: RequestHandlerType,\n) => number\n\nfunction getHttpHandlerScore(): ScoreGetterFn<HttpHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: Request,\n  handlers: Array<HttpHandler> | Array<GraphQLHandler>,\n  getScore: ScoreGetterFn<HttpHandler> | ScoreGetterFn<GraphQLHandler>,\n): Array<RequestHandler> {\n  const suggestedHandlers = (handlers as Array<RequestHandler>)\n    .reduce<Array<RequestHandlerSuggestion>>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport async function onUnhandledRequest(\n  request: Request,\n  handlers: Array<RequestHandler>,\n  strategy: UnhandledRequestStrategy = 'warn',\n): Promise<void> {\n  const parsedGraphQLQuery = await parseGraphQLRequest(request).catch(\n    () => null,\n  )\n  const publicUrl = getPublicUrlFromRequest(request)\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.http\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getHttpHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function getGraphQLRequestHeader(\n    parsedGraphQLRequest: ParsedGraphQLRequest<any>,\n  ): string {\n    if (!parsedGraphQLRequest?.operationName) {\n      return `anonymous ${parsedGraphQLRequest?.operationType} (${request.method} ${publicUrl})`\n    }\n\n    return `${parsedGraphQLRequest.operationType} ${parsedGraphQLRequest.operationName} (${request.method} ${publicUrl})`\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const requestHeader = parsedGraphQLQuery\n      ? getGraphQLRequestHeader(parsedGraphQLQuery)\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `intercepted a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}