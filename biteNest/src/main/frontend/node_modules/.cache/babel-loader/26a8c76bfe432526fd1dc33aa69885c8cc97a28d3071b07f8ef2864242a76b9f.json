{"ast":null,"code":"import { stringToHeaders } from \"headers-polyfill\";\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error) {\n    return void 0;\n  }\n}\nexport { parseMultipartData };","map":{"version":3,"names":["stringToHeaders","parseContentHeaders","headersString","_a","_b","headers","contentType","get","disposition","Error","directives","split","reduce","acc","chunk","name2","rest","trim","join","name","slice","filename","parseMultipartData","data","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","length","parsedBody","field","contentHeaders","contentBody","contentType2","value","File","type","parsedValue","Array","isArray","error"],"sources":["/Users/leeyangie/Documents/GitHub/BiteNest/biteNest/src/main/frontend/.yarn/unplugged/msw-virtual-7370ac2e06/node_modules/msw/lib/core/utils/internal/parseMultipartData.mjs"],"sourcesContent":["import { stringToHeaders } from \"headers-polyfill\";\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter((d) => d.startsWith(\"boundary=\")).map((s) => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data.split(boundaryRegExp).filter((chunk) => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map((chunk) => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const { contentType: contentType2, filename, name } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, { type: contentType2 });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error) {\n    return void 0;\n  }\n}\nexport {\n  parseMultipartData\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}