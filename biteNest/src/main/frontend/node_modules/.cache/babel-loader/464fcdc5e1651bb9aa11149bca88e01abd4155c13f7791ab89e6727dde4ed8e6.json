{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\"(exports, module) {\n    \"use strict\";\n\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n    function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    }\n    function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\", e);\n      }\n      var cookie = {\n        name,\n        value\n      };\n      parts.forEach(function (part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    }\n    function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n      return {\n        name,\n        value\n      };\n    }\n    function parse(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\");\n          }\n          input = sch;\n        }\n      }\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function (str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function (cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    }\n    function splitCookiesString(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n        return pos < cookiesString.length;\n      }\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n      return cookiesStrings;\n    }\n    module.exports = parse;\n    module.exports.parse = parse;\n    module.exports.parseString = parseString;\n    module.exports.splitCookiesString = splitCookiesString;\n  }\n});\n\n// src/store.ts\nvar import_set_cookie_parser = __toESM(require_set_cookie());\nvar PERSISTENCY_KEY = \"MSW_COOKIE_STORE\";\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false;\n    }\n    const testKey = PERSISTENCY_KEY + \"_test\";\n    localStorage.setItem(testKey, \"test\");\n    localStorage.getItem(testKey);\n    localStorage.removeItem(testKey);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\nvar hasLocalStorageSupport = supportsLocalStorage();\nfunction isPropertyAccessible(object, method) {\n  try {\n    object[method];\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar CookieStore = class {\n  constructor() {\n    this.store = /* @__PURE__ */new Map();\n  }\n  add(request, response) {\n    if (isPropertyAccessible(request, \"credentials\") && request.credentials === \"omit\") {\n      return;\n    }\n    const requestUrl = new URL(request.url);\n    const responseCookies = response.headers.get(\"set-cookie\");\n    if (!responseCookies) {\n      return;\n    }\n    const now = Date.now();\n    const parsedResponseCookies = (0, import_set_cookie_parser.parse)(responseCookies).map(({\n      maxAge,\n      ...cookie\n    }) => ({\n      ...cookie,\n      expires: maxAge === void 0 ? cookie.expires : new Date(now + maxAge * 1e3),\n      maxAge\n    }));\n    const prevCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */new Map();\n    parsedResponseCookies.forEach(cookie => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie));\n    });\n  }\n  get(request) {\n    this.deleteExpiredCookies();\n    const requestUrl = new URL(request.url);\n    const originCookies = this.store.get(requestUrl.origin) || /* @__PURE__ */new Map();\n    if (!isPropertyAccessible(request, \"credentials\")) {\n      return originCookies;\n    }\n    switch (request.credentials) {\n      case \"include\":\n        {\n          if (typeof document === \"undefined\") {\n            return originCookies;\n          }\n          const documentCookies = (0, import_set_cookie_parser.parse)(document.cookie);\n          documentCookies.forEach(cookie => {\n            originCookies.set(cookie.name, cookie);\n          });\n          return originCookies;\n        }\n      case \"same-origin\":\n        {\n          return originCookies;\n        }\n      default:\n        return /* @__PURE__ */new Map();\n    }\n  }\n  getAll() {\n    this.deleteExpiredCookies();\n    return this.store;\n  }\n  deleteAll(request) {\n    const requestUrl = new URL(request.url);\n    this.store.delete(requestUrl.origin);\n  }\n  clear() {\n    this.store.clear();\n  }\n  hydrate() {\n    if (!hasLocalStorageSupport) {\n      return;\n    }\n    const persistedCookies = localStorage.getItem(PERSISTENCY_KEY);\n    if (!persistedCookies) {\n      return;\n    }\n    try {\n      const parsedCookies = JSON.parse(persistedCookies);\n      parsedCookies.forEach(([origin, cookies]) => {\n        this.store.set(origin, new Map(cookies.map(([token, {\n          expires,\n          ...cookie\n        }]) => [token, expires === void 0 ? cookie : {\n          ...cookie,\n          expires: new Date(expires)\n        }])));\n      });\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`);\n      localStorage.removeItem(PERSISTENCY_KEY);\n    }\n  }\n  persist() {\n    if (!hasLocalStorageSupport) {\n      return;\n    }\n    const serializedCookies = Array.from(this.store.entries()).map(([origin, cookies]) => {\n      return [origin, Array.from(cookies.entries())];\n    });\n    localStorage.setItem(PERSISTENCY_KEY, JSON.stringify(serializedCookies));\n  }\n  deleteExpiredCookies() {\n    const now = Date.now();\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(({\n        expires,\n        name\n      }) => {\n        if (expires !== void 0 && expires.getTime() <= now) {\n          originCookies.delete(name);\n        }\n      });\n      if (originCookies.size === 0) {\n        this.store.delete(origin);\n      }\n    });\n  }\n};\nvar store = new CookieStore();\nexport { PERSISTENCY_KEY, store };","map":{"version":3,"names":["require_set_cookie","__commonJS","node_modules/set-cookie-parser/lib/set-cookie.js","exports","module","defaultParseOptions","decodeValues","map","silent","isNonEmptyString","str","trim","parseString","setCookieValue","options","parts","split","filter","nameValuePairStr","shift","parsed","parseNameValuePair","name","value","Object","assign","decodeURIComponent","e","console","error","cookie","forEach","part","sides","key","trimLeft","toLowerCase","value2","join","expires","Date","maxAge","parseInt","secure","httpOnly","sameSite","nameValueArr","length","parse","input","headers","getSetCookie","sch","keys","find","warn","Array","isArray","cookies","reduce","cookies2","splitCookiesString","cookiesString","cookiesStrings","pos","start","ch","lastComma","nextStart","cookiesSeparatorFound","skipWhitespace","test","charAt","notSpecialChar","push","substring","import_set_cookie_parser","__toESM","PERSISTENCY_KEY","supportsLocalStorage","localStorage","testKey","setItem","getItem","removeItem","hasLocalStorageSupport","isPropertyAccessible","object","method","CookieStore","constructor","store","Map","add","request","response","credentials","requestUrl","URL","url","responseCookies","get","now","parsedResponseCookies","prevCookies","origin","set","deleteExpiredCookies","originCookies","document","documentCookies","getAll","deleteAll","delete","clear","hydrate","persistedCookies","parsedCookies","JSON","token","persist","serializedCookies","from","entries","stringify","getTime","size"],"sources":["/Users/leeyangie/.yarn/berry/cache/@mswjs-cookies-npm-1.1.1-8c868f8e46-10c0.zip/node_modules/@mswjs/cookies/node_modules/set-cookie-parser/lib/set-cookie.js","/Users/leeyangie/.yarn/berry/cache/@mswjs-cookies-npm-1.1.1-8c868f8e46-10c0.zip/node_modules/@mswjs/cookies/src/store.ts"],"sourcesContent":["\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n","import { Cookie, parse as parseCookie } from 'set-cookie-parser'\n\ninterface RequestLike {\n  credentials: Request['credentials']\n  url: string\n}\n\ninterface HeadersLike {\n  get(name: string): string | null\n}\n\ninterface ResponseLike {\n  headers: HeadersLike\n}\n\nexport type Store = Map<string, StoreEntry>\nexport type StoreEntry = Map<string, Cookie>\nexport type CookieString = Omit<Cookie, 'expires'> & { expires?: string }\n\nexport const PERSISTENCY_KEY = 'MSW_COOKIE_STORE'\n\nfunction supportsLocalStorage() {\n  try {\n    if (localStorage == null) {\n      return false\n    }\n\n    const testKey = PERSISTENCY_KEY + '_test'\n\n    localStorage.setItem(testKey, 'test')\n    localStorage.getItem(testKey)\n    localStorage.removeItem(testKey)\n\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nconst hasLocalStorageSupport = supportsLocalStorage()\n\n/**\n * Checks that accessing a given property on an object\n * by name does not throw an error.\n *\n * This is generally used to avoid issues in environments\n * like `miniflare` where some properties are defined as getters\n * where accessing that property throws directly.\n */\nfunction isPropertyAccessible<Obj extends Record<string, any>>(\n  object: Obj,\n  method: keyof Obj,\n) {\n  try {\n    object[method]\n    return true\n  } catch {\n    return false\n  }\n}\n\nclass CookieStore {\n  private store: Store\n\n  constructor() {\n    this.store = new Map()\n  }\n\n  /**\n   * Sets the given request cookies into the store.\n   * Respects the `request.credentials` policy.\n   */\n  add(request: RequestLike, response: ResponseLike): void {\n    if (\n      isPropertyAccessible(request, 'credentials') &&\n      request.credentials === 'omit'\n    ) {\n      return\n    }\n\n    const requestUrl = new URL(request.url)\n    const responseCookies = response.headers.get('set-cookie')\n\n    if (!responseCookies) {\n      return\n    }\n\n    const now = Date.now()\n    const parsedResponseCookies = parseCookie(responseCookies).map(\n      ({ maxAge, ...cookie }) => ({\n        ...cookie,\n        expires:\n          maxAge === undefined ? cookie.expires : new Date(now + maxAge * 1000),\n        maxAge,\n      }),\n    )\n\n    const prevCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    parsedResponseCookies.forEach((cookie) => {\n      this.store.set(requestUrl.origin, prevCookies.set(cookie.name, cookie))\n    })\n  }\n\n  /**\n   * Returns cookies relevant to the given request\n   * and its `request.credentials` policy.\n   */\n  get(request: RequestLike): StoreEntry {\n    this.deleteExpiredCookies()\n\n    const requestUrl = new URL(request.url)\n    const originCookies =\n      this.store.get(requestUrl.origin) || new Map<string, Cookie>()\n\n    if (!isPropertyAccessible(request, 'credentials')) {\n      return originCookies\n    }\n\n    switch (request.credentials) {\n      case 'include': {\n        // Support running this method in Node.js.\n        if (typeof document === 'undefined') {\n          return originCookies\n        }\n\n        const documentCookies = parseCookie(document.cookie)\n\n        documentCookies.forEach((cookie) => {\n          originCookies.set(cookie.name, cookie)\n        })\n\n        return originCookies\n      }\n\n      case 'same-origin': {\n        return originCookies\n      }\n\n      default:\n        return new Map()\n    }\n  }\n\n  /**\n   * Returns a collection of all stored cookies.\n   */\n  getAll(): Store {\n    this.deleteExpiredCookies()\n    return this.store\n  }\n\n  /**\n   * Deletes all cookies associated with the given request.\n   */\n  deleteAll(request: RequestLike): void {\n    const requestUrl = new URL(request.url)\n    this.store.delete(requestUrl.origin)\n  }\n\n  /**\n   * Clears the entire cookie store.\n   */\n  clear(): void {\n    this.store.clear()\n  }\n\n  /**\n   * Hydrates the virtual cookie store from the `localStorage` if defined.\n   */\n  hydrate(): void {\n    if (!hasLocalStorageSupport) {\n      return\n    }\n\n    const persistedCookies = localStorage.getItem(PERSISTENCY_KEY)\n\n    if (!persistedCookies) {\n      return\n    }\n\n    try {\n      const parsedCookies: [string, [string, CookieString][]][] =\n        JSON.parse(persistedCookies)\n\n      parsedCookies.forEach(([origin, cookies]) => {\n        this.store.set(\n          origin,\n          new Map(\n            cookies.map(([token, { expires, ...cookie }]) => [\n              token,\n              expires === undefined\n                ? cookie\n                : { ...cookie, expires: new Date(expires) },\n            ]),\n          ),\n        )\n      })\n    } catch (error) {\n      console.warn(`\n[virtual-cookie] Failed to parse a stored cookie from the localStorage (key \"${PERSISTENCY_KEY}\").\n\nStored value:\n${localStorage.getItem(PERSISTENCY_KEY)}\n\nThrown exception:\n${error}\n\nInvalid value has been removed from localStorage to prevent subsequent failed parsing attempts.`)\n      localStorage.removeItem(PERSISTENCY_KEY)\n    }\n  }\n\n  /**\n   * Persists the current virtual cookies into the `localStorage` if defined,\n   * so they are available on the next page load.\n   */\n  persist(): void {\n    if (!hasLocalStorageSupport) {\n      return\n    }\n\n    const serializedCookies = Array.from(this.store.entries()).map(\n      ([origin, cookies]) => {\n        return [origin, Array.from(cookies.entries())]\n      },\n    )\n\n    localStorage.setItem(PERSISTENCY_KEY, JSON.stringify(serializedCookies))\n  }\n\n  private deleteExpiredCookies() {\n    const now = Date.now()\n\n    this.store.forEach((originCookies, origin) => {\n      originCookies.forEach(({ expires, name }) => {\n        if (expires !== undefined && expires.getTime() <= now) {\n          originCookies.delete(name)\n        }\n      })\n\n      if (originCookies.size === 0) {\n        this.store.delete(origin)\n      }\n    })\n  }\n}\n\nexport const store = new CookieStore()\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}