{"ast":null,"code":"// src/format.ts\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message, ...positionals) {\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\n\n// src/invariant.ts\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error) {\n  if (!error.stack) {\n    return;\n  }\n  const nextStack = error.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message, ...positionals) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = (predicate, message, ...positionals) => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error;\n    try {\n      error = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error = ErrorConstructor(formatMessage);\n    }\n    throw error;\n  }\n};\nexport { InvariantError, format, invariant };","map":{"version":3,"names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","positionals","length","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error","stack","nextStack","split","splice","InvariantError","Error","constructor","name","invariant","predicate","as","ErrorConstructor","formatMessage","Reflect","construct","err"],"sources":["/Users/leeyangie/.yarn/berry/cache/outvariant-npm-1.4.3-192f951f81-10c0.zip/node_modules/outvariant/src/format.ts","/Users/leeyangie/.yarn/berry/cache/outvariant-npm-1.4.3-192f951f81-10c0.zip/node_modules/outvariant/src/invariant.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}